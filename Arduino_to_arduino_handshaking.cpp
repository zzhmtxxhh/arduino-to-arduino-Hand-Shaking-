#include<Arduino.h>
/*This project is to communicated without exchaning key manually */


/*modulus for large number*/
uint32_t multiplication (uint32_t a, uint32_t b ,uint32_t m ){
  uint32_t r = 0 % m; // will store the result at the end
  uint32_t p = a % m; // will store a^{2^i} % m for i=0,1,...
  for (int i=0; i<32; ++i) {
    if ( (b & (1ul<<i))!=0 ) { // check i-th bit of b
      r = (r+p) % m;// the result of this sum can be (a(31st)*a*2^31+a(30th)*a*2^30+...+a(0th)*a*2^0)%m==(a*a)%m
                    //where a(i-th) (i from 0 to 31) could be 0 or 1
    }
    p = (p*2) % m;//calculate the (2^i)%m (i from 0 to 31)
  }
  return r;
}

uint32_t pow_mod( uint32_t a/* genenartor*/, uint32_t b /*private key*/, uint32_t m /*prime*/ ) {
  uint32_t r = 1 % m; // will store the result at the end
  uint32_t p = a % m; // will store a^{2^i} % m for i=0,1,...
  for (int i=0; i<32; ++i) {
    if ( (b & (1ul<<i))!=0 ) {
      r = multiplication(r, p, m);//p is expressed in bianry form by comparing with 1ul<<i
                                  //this function can calculate p(in binary)*p which is equal to p*p
    }
    p = multiplication(p,p,m);//this function can calculate the (p*p)%m which can be used to get the binary form
                              //of the second parameter in the previous multiplication
  }
  return r;
}

/*the below fuction is to generate a 32 bit randon number */
uint32_t ranvalue(){
  uint32_t a = 0;
  uint32_t b = 0;
  int analogpin = 1 ;
  int l = 0 ;
  uint32_t r = 0 ;
  while (l < 31 ){
    // get the least sginificant digit of each digits
    a = analogRead(analogpin);
    b = a % 2;
    r += b << (31-l);
    ++l;
    delay(50);
  }
  return r ;
}


// The below fuction is to generate a 32 bit public_key
uint32_t public_key(uint32_t private_key){//
  uint32_t prime = 2147483647;
  uint32_t generator = 16807 ;
  uint32_t public_key = pow_mod(generator , private_key, prime);
  return public_key;
}

/** Waits for a certain number of bytes on Serial3 or timeout
 * @param nbytes: the number of bytes we want
 * @param timeout: timeout period (ms); specifying a negative number
 *                turns off timeouts (the function waits indefinitely
 *                if timeouts are turned off).
 * @return True if the required number of bytes have arrived.
 */
bool wait_on_serial3( uint8_t nbytes, long timeout ) {
  unsigned long deadline = millis() + timeout;//wraparound not a problem
  while (Serial3.available()<nbytes && (timeout<0 || millis()<deadline))
  {
    delay(1); // be nice, no busy loop
  }
  return Serial3.available()>=nbytes;
}

/** Writes an uint32_t to Serial3, starting from the least-significant
 * and finishing with the most significant byte.
 */
void uint32_to_serial3(uint32_t num) {
  Serial3.write((char) (num >> 0));
  Serial3.write((char) (num >> 8));
  Serial3.write((char) (num >> 16));
  Serial3.write((char) (num >> 24));
}

/** Reads an uint32_t from Serial3, starting from the least-significant
 * and finishing with the most significant byte.
 */
uint32_t uint32_from_serial3() {
  uint32_t num = 0;
  num = num | ((uint32_t) Serial3.read()) << 0;
  num = num | ((uint32_t) Serial3.read()) << 8;
  num = num | ((uint32_t) Serial3.read()) << 16;
  num = num | ((uint32_t) Serial3.read()) << 24;
  return num;
}

/*The below part is for client to receive skey send ckey to server
*/
uint32_t client (uint32_t private_key){//
  char CR = 'C';
  char ACK = 'A';
  uint32_t ckey = public_key(private_key);//
  Serial.print("The public key generated by client is:");
  Serial.println(ckey);
  uint32_t skey = 0 ;
  enum State { Start , WFA, DONE};// initial finite state
  State curr_state = Start ;// state #1
  while (true) {
    if (curr_state == Start){
      Serial3.write(CR); //send CR
      uint32_to_serial3(ckey);//send KEY
      curr_state = WFA ;
    }
    else if ( curr_state == WFA && (wait_on_serial3(5,1000) ) ){ //should receieved 5 byte information
      if (Serial3.read() == ACK) { // consume 1 byte
        skey = uint32_from_serial3(); // consume 4 byte
        Serial3.write(ACK); // send acknowledgement
        curr_state = DONE;
        break;
      }
    }
    else { // if cannot fufill the above condition  go to the start
      curr_state = Start ;
    }
  }
  Serial.print("The Skey receieve from the server :");
  Serial.println(skey); // return skey
  return skey;
}
/*The below fucntion is for server to send the skey receieve the ckey */
uint32_t Server (uint32_t private_key){
  char CR = 'C';//67
  char ACK = 'A';//65
  enum State { Listen , WFK , WFA , DONE }; // initialize the finite state
  State curr_state = Listen ;
  uint32_t skey = public_key(private_key);//
  Serial.print("The public key generated by server:");
  Serial.println(skey);
  uint32_t ckey = 0 ;

  while (true){
    if (curr_state == Listen &&  (Serial3.read() == CR )){
      //whether receieve cr or not and consume 1 byte
      curr_state = WFK;
    }
    else if (curr_state == WFK)  { // go to waitforkey
      if (wait_on_serial3(4,1000 ) ){ // wait for 4 byte
      ckey = uint32_from_serial3();
      //receieve ckey and consume 4 byte
      Serial3.write(ACK);// send acknowledgement
      uint32_to_serial3(skey);//
      curr_state = WFA;
    }
    else { // if cannot fullfill the above condiiton go back to listen
      curr_state = Listen;
    }
    }

    else if (curr_state == WFA){ // go to waitforacknowledgement
      if (wait_on_serial3(1,1000 ) ) { // wait for one byte either C or A
      char incomingByte = Serial3.read();
      if (incomingByte == CR) { // consume C one byte
        curr_state = WFK ; // go the waitforkey
      }
      else if (incomingByte == ACK){ // consume A one byte
        curr_state = DONE ; // done all the state
        break;
      }
    }
    else { // if cannot fullfill the above conditon go back to listen
      curr_state = Listen;
    }
    }
  }
  Serial.print("THe ckey receieved from client : ");
  Serial.println(ckey); // return ckey
  return ckey;
}

/** Implements the Park-Miller algorithm with 32 bit integer arithmetic
 * @return ((current_key * 48271)) mod (2^31 - 1);
 * This is linear congruential generator, based on the multiplicative
 * group of integers modulo m = 2^31 - 1.
 * The generator has a long period and it is relatively efficient.
 * Most importantly, the generator's modulus is not a power of two
 * (as is for the built-in rng),
 * hence the keys mod 2^{s} cannot be obtained
 * by using a key with s bits.
 * Based on:
 * http://www.firstpr.com.au/dsp/rand31/rand31-park-miller-carta.cc.txt
 */
uint32_t next_key(uint32_t current_key) {
  const uint32_t modulus = 0x7FFFFFFF; // 2^31-1
  const uint32_t consta = 48271;  // we use that consta<2^16
  uint32_t lo = consta*(current_key & 0xFFFF);
  uint32_t hi = consta*(current_key >> 16);
  lo += (hi & 0x7FFF)<<16;
  lo += hi>>15;
  if (lo > modulus) lo -= modulus;
  return lo;
}


int main() {
  init();
  Serial.begin(9600);
  Serial3.begin(9600); // initialized
  int analogpin = 13 ;
  uint32_t prime = 2147483647 ;
  uint32_t int_secret_key = 0;
  //testpowmod();
  uint32_t private_key = ranvalue();
  int mode = digitalRead(analogpin);//
  if (mode == 1 ){//when u r Server
    Serial.println("u r Server");
    uint32_t partner_public_key = Server(private_key);//get ckey
    Serial.print("partner_public_key :");
    Serial.println(partner_public_key);
    int_secret_key = pow_mod(partner_public_key, private_key, prime);//prime doesn't declare
  }

  else if (mode == 0){//when u r client
    Serial.println("u r client");
    uint32_t partner_public_key = client(private_key);//get skey
    Serial.print("partner_public_key :");
    Serial.println(partner_public_key);
    int_secret_key = pow_mod(partner_public_key, private_key, prime);//prime doesn't declare
  }
  Serial.print("the computed secret key in integer: ");
  Serial.println(int_secret_key);
  Serial.println("lets talk");
  char secret_key = int_secret_key; // lowest 8 bits of the shated secret_key
  while (true) {
    // PC keystroke -> other Arduino
    if (Serial.available()>0) {
      char c = Serial.read();
      // Serial.write(c); // echo back to screen
      Serial.print("ASCII code of character to be sent: ");
      Serial.println((int)c);
      c = c ^ secret_key;
      Serial.print("Encrypted information being sent: ");
      Serial.println((int)c);
      /*Not sure whether we need to keep the above two lines of code or not
      */
      Serial3.write(c); // sending byte to the "other" Arduino
      int_secret_key = next_key(int_secret_key);// create a new secret key
      char secret_key = int_secret_key;// repalce the new secret key to old secret key
    }

    // Other Arduino to PC screen
    if (Serial3.available()>0) {
      char c = Serial3.read();
      // decrypt data:
      c = c ^ secret_key;
      Serial.write(c); // show byte on screen as character
      int_secret_key = next_key(int_secret_key);//
      char secret_key = int_secret_key;//
    }
  }
  Serial3.end();
  Serial.end();
  return 0;
}
